"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const AWS = require("aws-sdk");
const sharp = require("sharp");
const error_1 = require("./error");
const s3 = new AWS.S3({ apiVersion: '2006-03-01' });
const allowOrigins = (process.env.ALLOW_ORIGINS || '').split(',');
const storageClass = process.env.STORAGE_CLASS || 'STANDARD_IA';
const maxAgeSeconds = process.env.MAX_AGE_SECONDS || '604800'; // 7 days
/**
 * Returns header object with CORS headers set
 */
function getHeaders(event) {
    const headers = {};
    const originHeader = event.headers.origin || event.headers.Origin;
    const origin = allowOrigins.find((origin) => origin === originHeader);
    if (origin) {
        headers['Access-Control-Allow-Origin'] = origin;
        headers['Access-Control-Allow-Credentials'] = true;
    }
    return headers;
}
/**
 * Extracts dimensions from a string e.g '300', '300x400' or 'x400'
 */
function dimensionsFromPathString(str) {
    if (!str)
        throw new Error('Invalid dimensions');
    const regex = /(\d*)x?(\d*)/;
    const matches = str.match(regex);
    const width = matches[1] ? Number(matches[1]) : undefined;
    const height = matches[2] ? Number(matches[2]) : undefined;
    if ((!width && !height) || width === 0 || height === 0)
        throw new Error('Invalid dimensions');
    return {
        width,
        height,
    };
}
/**
 * Converts object implementing Dimensions to string
 */
function dimensionsToPathString(dimensions) {
    if (dimensions.width && dimensions.height === undefined)
        return `${dimensions.width}`;
    if (dimensions.width === undefined && dimensions.height)
        return `x${dimensions.height}`;
    if (dimensions.width === undefined && dimensions.height === undefined)
        return '';
    return `${dimensions.width}x${dimensions.height}`;
}
/**
 * Lambda error handler
 */
function handleError(err, event) {
    console.log(err);
    return {
        statusCode: err.statusCode || 500,
        headers: getHeaders(event),
        body: JSON.stringify({
            message: err.message || 'An unhandled error occurred',
        }),
    };
}
exports.handler = async (event) => {
    console.log('Path: ', event.path);
    // Split path on '/' and make sure it has at least 2 segments
    const splitPath = event.path.split('/').filter((segment) => segment);
    if (splitPath.length < 2)
        return handleError(new error_1.NotFoundError(), event);
    // Extract dimensions from path segment
    let dimensions;
    try {
        dimensions = dimensionsFromPathString(splitPath[0]);
    }
    catch (err) {
        return handleError(new error_1.ClientError(err.message), event);
    }
    // The last segment of the path will be the s3 key we're resizing. For example
    // if the path is '/300x300/foo/bar.png' we extract 'foo/bar.png'
    const sourceKey = splitPath.slice(1).join('/');
    // Construct the destination key
    const destinationKey = `${dimensionsToPathString(dimensions)}/${sourceKey}`;
    try {
        const obj = await s3
            .getObject({
            Bucket: process.env.BUCKET_NAME,
            Key: sourceKey,
        })
            .promise();
        const imageBuffer = await sharp(obj.Body)
            .resize(dimensions)
            .toBuffer();
        await s3
            .putObject({
            Bucket: process.env.BUCKET_NAME,
            Key: destinationKey,
            Body: imageBuffer,
            ContentType: obj.ContentType,
            CacheControl: `max-age=${maxAgeSeconds}`,
            StorageClass: storageClass,
        })
            .promise();
    }
    catch (err) {
        return handleError(err, event);
    }
    // Redirect to our cloudfront endpoint
    const headers = getHeaders(event);
    headers['location'] = `https://${process.env
        .CLOUDFRONT_DOMAIN_NAME}/${destinationKey}`;
    headers['cache-control'] = 'max-age=0';
    return {
        statusCode: 302,
        headers,
    };
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLCtCQUErQjtBQUMvQiwrQkFBK0I7QUFDL0IsbUNBQXFEO0FBRXJELE1BQU0sRUFBRSxHQUFHLElBQUksR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLFVBQVUsRUFBRSxZQUFZLEVBQUUsQ0FBQyxDQUFDO0FBRXBELE1BQU0sWUFBWSxHQUFHLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxhQUFhLElBQUksRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ2xFLE1BQU0sWUFBWSxHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsYUFBYSxJQUFJLGFBQWEsQ0FBQztBQUNoRSxNQUFNLGFBQWEsR0FBRyxPQUFPLENBQUMsR0FBRyxDQUFDLGVBQWUsSUFBSSxRQUFRLENBQUMsQ0FBQyxTQUFTO0FBT3hFOztHQUVHO0FBQ0gsU0FBUyxVQUFVLENBQUMsS0FBcUM7SUFDdkQsTUFBTSxPQUFPLEdBQXdDLEVBQUUsQ0FBQztJQUN4RCxNQUFNLFlBQVksR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQztJQUNsRSxNQUFNLE1BQU0sR0FBRyxZQUFZLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxNQUFNLEtBQUssWUFBWSxDQUFDLENBQUM7SUFDdEUsSUFBSSxNQUFNLEVBQUU7UUFDVixPQUFPLENBQUMsNkJBQTZCLENBQUMsR0FBRyxNQUFNLENBQUM7UUFDaEQsT0FBTyxDQUFDLGtDQUFrQyxDQUFDLEdBQUcsSUFBSSxDQUFDO0tBQ3BEO0lBQ0QsT0FBTyxPQUFPLENBQUM7QUFDakIsQ0FBQztBQUVEOztHQUVHO0FBQ0gsU0FBUyx3QkFBd0IsQ0FBQyxHQUFXO0lBQzNDLElBQUksQ0FBQyxHQUFHO1FBQUUsTUFBTSxJQUFJ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QU87S0FDUixDQUFDO0FBQ0osQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQVdTIGZyb20gJ2F3cy1zZGsnO1xuaW1wb3J0ICogYXMgc2hhcnAgZnJvbSAnc2hhcnAnO1xuaW1wb3J0IHsgQ2xpZW50RXJyb3IsIE5vdEZvdW5kRXJyb3IgfSBmcm9tICcuL2Vycm9yJztcblxuY29uc3QgczMgPSBuZXcgQVdTLlMzKHsgYXBpVmVyc2lvbjogJzIwMDYtMDMtMDEnIH0pO1xuXG5jb25zdCBhbGxvd09yaWdpbnMgPSAocHJvY2Vzcy5lbnYuQUxMT1dfT1JJR0lOUyB8fCAnJykuc3BsaXQoJywnKTtcbmNvbnN0IHN0b3JhZ2VDbGFzcyA9IHByb2Nlc3MuZW52LlNUT1JBR0VfQ0xBU1MgfHwgJ1NUQU5EQVJEX0lBJztcbmNvbnN0IG1heEFnZVNlY29uZHMgPSBwcm9jZXNzLmVudi5NQVhfQUdFX1NFQ09ORFMgfHwgJzYwNDgwMCc7IC8vIDcgZGF5c1xuXG5pbnRlcmZhY2UgRGltZW5zaW9ucyB7XG4gIHdpZHRoPzogbnVtYmVyO1xuICBoZWlnaHQ/OiBudW1iZXI7XG59XG5cbi8qKlxuICogUmV0dXJucyBoZWFkZXIgb2JqZWN0IHdpdGggQ09SUyBoZWFkZXJzIHNldFxuICovXG5mdW5jdGlvbiBnZXRIZWFkZXJzKGV2ZW50OiBBV1NMYW1iZGEuQVBJR2F0ZXdheVByb3h5RXZlbnQpIHtcbiAgY29uc3QgaGVhZGVyczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfCBib29sZWFuIH0gPSB7fTtcbiAgY29uc3Qgb3JpZ2luSGVhZGVyID0gZXZlbnQuaGVhZGVycy5vcmlnaW4gfHwgZXZlbnQuaGVhZGVycy5PcmlnaW47XG4gIGNvbnN0IG9yaWdpbiA9IGFsbG93T3JpZ2lucy5maW5kKChvcmlnaW4pID0+IG9yaWdpbiA9PT0gb3JpZ2luSGVhZGVyKTtcbiAgaWYgKG9yaWdpbikge1xuICAgIGhlYWRlcnNbJ0FjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpbiddID0gb3JpZ2luO1xuICAgIGhlYWRlcnNbJ0FjY2Vzcy1Db250cm9sLUFsbG93LUNyZWRlbnRpYWxzJ10gPSB0cnVlO1xuICB9XG4gIHJldHVybiBoZWFkZXJzO1xufVxuXG4vKipcbiAqIEV4dHJhY3RzIGRpbWVuc2lvbnMgZnJvbSBhIHN0cmluZyBlLmcgJzMwMCcsICczMDB4NDAwJyBvciAneDQwMCdcbiAqL1xuZnVuY3Rpb24gZGltZW5zaW9uc0Zyb21QYXRoU3RyaW5nKHN0cjogc3RyaW5nKTogRGltZW5zaW9ucyB7XG4gIGlmICghc3RyKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZGltZW5zaW9ucycpO1xuICBjb25zdCByZWdleCA9IC8oXFxkKil4PyhcXGQqKS87XG4gIGNvbnN0IG1hdGNoZXMgPSBzdHIubWF0Y2gocmVnZXgpITtcbiAgY29uc3Qgd2lkdGggPSBtYXRjaGVzWzFdID8gTnVtYmVyKG1hdGNoZXNbMV0pIDogdW5kZWZpbmVkO1xuICBjb25zdCBoZWlnaHQgPSBtYXRjaGVzWzJdID8gTnVtYmVyKG1hdGNoZXNbMl0pIDogdW5kZWZpbmVkO1xuICBpZiAoKCF3aWR0aCAmJiAhaGVpZ2h0KSB8fCB3aWR0aCA9PT0gMCB8fCBoZWlnaHQgPT09IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGRpbWVuc2lvbnMnKTtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gIH07XG59XG5cbi8qKlxuICogQ29udmVydHMgb2JqZWN0IGltcGxlbWVudGluZyBEaW1lbnNpb25zIHRvIHN0cmluZ1xuICovXG5mdW5jdGlvbiBkaW1lbnNpb25zVG9QYXRoU3RyaW5nKGRpbWVuc2lvbnM6IERpbWVuc2lvbnMpIHtcbiAgaWYgKGRpbWVuc2lvbnMud2lkdGggJiYgZGltZW5zaW9ucy5oZWlnaHQgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gYCR7ZGltZW5zaW9ucy53aWR0aH1gO1xuICBpZiAoZGltZW5zaW9ucy53aWR0aCA9PT0gdW5kZWZpbmVkICYmIGRpbWVuc2lvbnMuaGVpZ2h0KVxuICAgIHJldHVybiBgeCR7ZGltZW5zaW9ucy5oZWlnaHR9YDtcbiAgaWYgKGRpbWVuc2lvbnMud2lkdGggPT09IHVuZGVmaW5lZCAmJiBkaW1lbnNpb25zLmhlaWdodCA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiAnJztcbiAgcmV0dXJuIGAke2RpbWVuc2lvbnMud2lkdGh9eCR7ZGltZW5zaW9ucy5oZWlnaHR9YDtcbn1cblxuLyoqXG4gKiBMYW1iZGEgZXJyb3IgaGFuZGxlclxuICovXG5mdW5jdGlvbiBoYW5kbGVFcnJvcihlcnI6IGFueSwgZXZlbnQ6IEFXU0xhbWJkYS5BUElHYXRld2F5UHJveHlFdmVudCkge1xuICBjb25zb2xlLmxvZyhlcnIpO1xuICByZXR1cm4ge1xuICAgIHN0YXR1c0NvZGU6IGVyci5zdGF0dXNDb2RlIHx8IDUwMCxcbiAgICBoZWFkZXJzOiBnZXRIZWFkZXJzKGV2ZW50KSxcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBtZXNzYWdlOiBlcnIubWVzc2FnZSB8fCAnQW4gdW5oYW5kbGVkIGVycm9yIG9jY3VycmVkJyxcbiAgICB9KSxcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IGhhbmRsZXIgPSBhc3luYyAoZXZlbnQ6IEFXU0xhbWJkYS5BUElHYXRld2F5UHJveHlFdmVudCkgPT4ge1xuICBjb25zb2xlLmxvZygnUGF0aDogJywgZXZlbnQucGF0aCk7XG5cbiAgLy8gU3BsaXQgcGF0aCBvbiAnLycgYW5kIG1ha2Ugc3VyZSBpdCBoYXMgYXQgbGVhc3QgMiBzZWdtZW50c1xuICBjb25zdCBzcGxpdFBhdGggPSBldmVudC5wYXRoLnNwbGl0KCcvJykuZmlsdGVyKChzZWdtZW50KSA9PiBzZWdtZW50KTtcbiAgaWYgKHNwbGl0UGF0aC5sZW5ndGggPCAyKSByZXR1cm4gaGFuZGxlRXJyb3IobmV3IE5vdEZvdW5kRXJyb3IoKSwgZXZlbnQpO1xuXG4gIC8vIEV4dHJhY3QgZGltZW5zaW9ucyBmcm9tIHBhdGggc2VnbWVudFxuICBsZXQgZGltZW5zaW9ucztcbiAgdHJ5IHtcbiAgICBkaW1lbnNpb25zID0gZGltZW5zaW9uc0Zyb21QYXRoU3RyaW5nKHNwbGl0UGF0aFswXSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBoYW5kbGVFcnJvcihuZXcgQ2xpZW50RXJyb3IoZXJyLm1lc3NhZ2UpLCBldmVudCk7XG4gIH1cblxuICAvLyBUaGUgbGFzdCBzZWdtZW50IG9mIHRoZSBwYXRoIHdpbGwgYmUgdGhlIHMzIGtleSB3ZSdyZSByZXNpemluZy4gRm9yIGV4YW1wbGVcbiAgLy8gaWYgdGhlIHBhdGggaXMgJy8zMDB4MzAwL2Zvby9iYXIucG5nJyB3ZSBleHRyYWN0ICdmb28vYmFyLnBuZydcbiAgY29uc3Qgc291cmNlS2V5ID0gc3BsaXRQYXRoLnNsaWNlKDEpLmpvaW4oJy8nKTtcblxuICAvLyBDb25zdHJ1Y3QgdGhlIGRlc3RpbmF0aW9uIGtleVxuICBjb25zdCBkZXN0aW5hdGlvbktleSA9IGAke2RpbWVuc2lvbnNUb1BhdGhTdHJpbmcoZGltZW5zaW9ucyl9LyR7c291cmNlS2V5fWA7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBvYmogPSBhd2FpdCBzM1xuICAgICAgLmdldE9iamVjdCh7XG4gICAgICAgIEJ1Y2tldDogcHJvY2Vzcy5lbnYuQlVDS0VUX05BTUUhLFxuICAgICAgICBLZXk6IHNvdXJjZUtleSxcbiAgICAgIH0pXG4gICAgICAucHJvbWlzZSgpO1xuXG4gICAgY29uc3QgaW1hZ2VCdWZmZXIgPSBhd2FpdCBzaGFycChvYmouQm9keSBhcyBCdWZmZXIpXG4gICAgICAucmVzaXplKGRpbWVuc2lvbnMpXG4gICAgICAudG9CdWZmZXIoKTtcblxuICAgIGF3YWl0IHMzXG4gICAgICAucHV0T2JqZWN0KHtcbiAgICAgICAgQnVja2V0OiBwcm9jZXNzLmVudi5CVUNLRVRfTkFNRSEsXG4gICAgICAgIEtleTogZGVzdGluYXRpb25LZXksXG4gICAgICAgIEJvZHk6IGltYWdlQnVmZmVyLFxuICAgICAgICBDb250ZW50VHlwZTogb2JqLkNvbnRlbnRUeXBlLFxuICAgICAgICBDYWNoZUNvbnRyb2w6IGBtYXgtYWdlPSR7bWF4QWdlU2Vjb25kc31gLFxuICAgICAgICBTdG9yYWdlQ2xhc3M6IHN0b3JhZ2VDbGFzcyxcbiAgICAgIH0pXG4gICAgICAucHJvbWlzZSgpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gaGFuZGxlRXJyb3IoZXJyLCBldmVudCk7XG4gIH1cblxuICAvLyBSZWRpcmVjdCB0byBvdXIgY2xvdWRmcm9udCBlbmRwb2ludFxuICBjb25zdCBoZWFkZXJzID0gZ2V0SGVhZGVycyhldmVudCk7XG4gIGhlYWRlcnNbJ2xvY2F0aW9uJ10gPSBgaHR0cHM6Ly8ke3Byb2Nlc3MuZW52XG4gICAgLkNMT1VERlJPTlRfRE9NQUlOX05BTUUhfS8ke2Rlc3RpbmF0aW9uS2V5fWA7XG4gIGhlYWRlcnNbJ2NhY2hlLWNvbnRyb2wnXSA9ICdtYXgtYWdlPTAnO1xuXG4gIHJldHVybiB7XG4gICAgc3RhdHVzQ29kZTogMzAyLFxuICAgIGhlYWRlcnMsXG4gIH07XG59O1xuIl19